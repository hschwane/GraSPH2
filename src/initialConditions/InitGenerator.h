/*
 * GraSPH2
 * InitGenerator.h
 *
 * @author: Hendrik Schwanekamp
 * @mail:   hendrik.schwanekamp@gmx.net
 *
 * Implements the InitGenerator class
 *
 * Copyright (c) 2018 Hendrik Schwanekamp
 *
 */

#ifndef GRASPH2_INITGENERATOR_H
#define GRASPH2_INITGENERATOR_H

// includes
//--------------------
#include <vector>
#include <functional>
#include <utility>
#include "ParticleSource.h"
//--------------------

//-------------------------------------------------------------------
/**
 * class initGenerator
 * Generates initial conditions for the simulation.
 *
 * usage:
 * Use the addParticles function to pass particle sources with modifiers to get particles from.
 * When all sources are added generate a particle buffer containing the particles from all sources using generate().
 *
 */
template <typename hostParticleType>
class InitGenerator
{
public:
    template <typename ParticleSourceType>
    void addParticles(ParticleSourceType particleSource, bool correctCOM = false, bool correctVelOfCOM = false); //!< adds a particle source to get particles from

    hostParticleType generate(); //!< generates the initial conditions and returns a host buffer with particle data

    size_t numberOfParticles(){return m_totalNumOfParticles;} //!< shows how many particles will be generated once "generate()" is called

private:

    //!< data needed to generate particles from one particle source
    struct sourceData
    {
        sourceData(size_t startID, size_t endID, const f3_t &desiredCOM, const f3_t &desiredVelOfCOM, bool correctCOM,
                   bool correctVelOfCom, const std::function<void(hostParticleType &, size_t, size_t)> &genFunc)
                : startID(startID), endID(endID), desiredCOM(desiredCOM), desiredVelOfCOM(desiredVelOfCOM),
                  correctCOM(correctCOM), correctVelOfCom(correctVelOfCom), genFunc(genFunc) {}

        size_t startID;
        size_t endID;
        f3_t desiredCOM;
        f3_t desiredVelOfCOM;
        bool correctCOM;
        bool correctVelOfCom;
        std::function< void(hostParticleType&,size_t,size_t)> genFunc;
    };

    std::vector<sourceData> m_sources; //!< data on all the particle sources

    size_t m_totalNumOfParticles{0}; //!< the total number of particles generated by this generator
};


// template function definitions of the InitGenerator class
//-------------------------------------------------------------------

template<typename hostParticleType>
template<typename ParticleSourceType>
void InitGenerator<hostParticleType>::addParticles(ParticleSourceType particleSource, bool correctCOM, bool correctVelOfCOM)
{
    static_assert(std::is_base_of<ps::detail::ParticleSourceBaseFlag,ParticleSourceType>::value, "particleSource must be an object of a class derived from the ParticleSource class!");

    size_t numParticles = particleSource.getNumParticles();

    m_sources.emplace_back( m_totalNumOfParticles,
                            m_totalNumOfParticles+numParticles,
                            particleSource.getDesiredCOM(),
                            particleSource.getDesiredVelOfCOM(),
                            correctCOM,
                            correctVelOfCOM,
                            std::function< void(hostParticleType&,size_t,size_t)>(particleSource));
    m_totalNumOfParticles += numParticles;
}

template<typename hostParticleType>
hostParticleType InitGenerator<hostParticleType>::generate()
{
    logINFO("InitialConditions") << "Getting " << m_totalNumOfParticles << " particles from particle sources.";

    // create a buffer to hold the particles
    hostParticleType hpb(m_totalNumOfParticles);
    hpb.initialize();

    size_t p=0; // we count the overall number of particles created over all sources

    // loop over all particle sources
    for(auto& s : m_sources)
    {
        // all particles that need to be generated by this source
        for(size_t j = s.startID; j < s.endID; ++j, ++p)
        {
            // generate particle using the generation function i with index j and put it into hpb at position p
            s.genFunc(hpb, j-s.startID, p);
        }

        // now if necessary correct COM / VelocityOfCOM
        if(s.correctCOM || s.correctVelOfCom)
        {
            f3_t COM{0,0,0};
            f1_t totalMass = 0;
            f3_t velOfCOM{0,0,0};
            for(size_t j = s.startID; j < s.endID; ++j)
            {
                auto particle = hpb.template loadParticle<POS,MASS,VEL>(j);

                totalMass += particle.mass;
                COM += particle.mass * particle.pos;
                velOfCOM += particle.mass * particle.vel;
            }
            COM /= totalMass;
            velOfCOM /= totalMass;

            f3_t COMcorrection{0,0,0};
            f3_t velOfCOMcorrection{0,0,0};
            if(s.correctCOM)
            {
                COMcorrection = s.desiredCOM - COM;
                logDEBUG("InitialConditions") << "Adjusting COM by " << COMcorrection;
            }
            if(s.correctVelOfCom)
            {
                velOfCOMcorrection = s.desiredVelOfCOM - velOfCOM;
                logDEBUG("InitialConditions") << "Adjusting velocity of COM by " << COMcorrection;
            }

            for(size_t j = s.startID; j < s.endID; ++j)
            {
                auto particle = hpb.template loadParticle<POS,MASS,VEL>(j);

                particle.pos += COMcorrection;
                particle.vel += velOfCOMcorrection;

                hpb.storeParticle(j,particle);
            }
        }
    }
    return hpb;
}


#endif //GRASPH2_INITGENERATOR_H
